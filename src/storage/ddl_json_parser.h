#ifndef DDL_JSON_PARSER_H
#define DDL_JSON_PARSER_H

/* Generated by flatcc 0.4.1-pre FlatBuffers schema compiler for C by dvide.com */

#include "flatcc/flatcc_json_parser.h"
#define PDIAGNOSTIC_IGNORE_UNUSED
#include "flatcc/portable/pdiagnostic_push.h"

/*
 * Parses the default root table or struct of the schema and constructs a FlatBuffer.
 *
 * Builder `B` must be initialized. `ctx` can be null but will hold
 * hold detailed error info on return when available.
 * Returns 0 on success, or error code.
 * `flags` : 0 by default, `flatcc_json_parser_f_skip_unknown` silently
 * ignores unknown table and structs fields, and union types.
 */
static int ddl_parse_json(flatcc_builder_t *B, flatcc_json_parser_t *ctx,
        const char *buf, size_t bufsiz, int flags);

static const char *dsim_ddl_numeric_type_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end);
static const char *dsim_ddl_struct_field_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end);
static const char *dsim_ddl_struct_type_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end);
static const char *dsim_ddl_enum_type_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end);
static const char *dsim_ddl_reference_type_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end);
static const char *dsim_ddl_any_type_parse_json_union(flatcc_json_parser_t *ctx, const char *buf, const char *end, uint8_t type, flatbuffers_voffset_t id);
static const char *dsim_ddl_any_type_parse_json_enum(flatcc_json_parser_t *ctx, const char *buf, const char *end,
        int *value_type, uint64_t *value, int *aggregate);
static const char *dsim_ddl_type_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end);
static const char *dsim_ddl_array_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end);
static const char *dsim_ddl_layout_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end);
static const char *dsim_ddl_storage_engine_parse_json_union(flatcc_json_parser_t *ctx, const char *buf, const char *end, uint8_t type, flatbuffers_voffset_t id);
static const char *dsim_ddl_storage_engine_parse_json_enum(flatcc_json_parser_t *ctx, const char *buf, const char *end,
        int *value_type, uint64_t *value, int *aggregate);
static const char *dsim_ddl_hash_storage_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end);
static const char *dsim_ddl_storage_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end);
static const char *dsim_ddl_root_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end);
static const char *ddl_local_json_parser_enum(flatcc_json_parser_t *ctx, const char *buf, const char *end,
int *value_type, uint64_t *value, int *aggregate);
static const char *ddl_local_dsim_ddl_json_parser_enum(flatcc_json_parser_t *ctx, const char *buf, const char *end,
int *value_type, uint64_t *value, int *aggregate);
static const char *ddl_global_json_parser_enum(flatcc_json_parser_t *ctx, const char *buf, const char *end,
        int *value_type, uint64_t *value, int *aggregate);

static const char *dsim_ddl_numeric_type_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end)
{
    int more;
    void *pval;
    flatcc_builder_ref_t ref, *pref;
    const char *mark;
    uint64_t w;
    flatcc_json_parser_escape_buffer_t code;

    if (flatcc_builder_start_table(ctx->ctx, 2)) goto failed;
    buf = flatcc_json_parser_object_start(ctx, buf, end, &more);
    while (more) {
        buf = flatcc_json_parser_symbol_start(ctx, buf, end);
        w = flatcc_json_parser_symbol_part(buf, end);
        if (w < 0x69735f7369676e65) { /* branch "is_signe" */
            if (w == 0x69735f666c6f6174) { /* "is_float" */
                buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 8);
                if (mark != buf) {
                    uint8_t val = 0;
                    static flatcc_json_parser_integral_symbol_f *symbolic_parsers[] = {
                            ddl_local_dsim_ddl_json_parser_enum,
                            ddl_global_json_parser_enum, 0 };
                    buf = flatcc_json_parser_bool(ctx, (mark = buf), end, &val);
                    if (mark == buf) {
                        buf = flatcc_json_parser_symbolic_bool(ctx, (mark = buf), end, symbolic_parsers, &val);
                        if (buf == mark || buf == end) goto failed;
                    }
                    if (val != 0 || (ctx->flags & flatcc_json_parser_f_force_add)) {
                        if (!(pval = flatcc_builder_table_add(ctx->ctx, 1, 1, 1))) goto failed;
                        flatbuffers_bool_write_to_pe(pval, val);
                    }
                } else {
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                }
            } else { /* "is_float" */
                buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
            } /* "is_float" */
        } else { /* branch "is_signe" */
            if (w == 0x69735f7369676e65) { /* prefix "is_signe" */
                buf += 8;
                w = flatcc_json_parser_symbol_part(buf, end);
                if ((w & 0xff00000000000000) == 0x6400000000000000) { /* "d" */
                    buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 1);
                    if (mark != buf) {
                        uint8_t val = 0;
                        static flatcc_json_parser_integral_symbol_f *symbolic_parsers[] = {
                                ddl_local_dsim_ddl_json_parser_enum,
                                ddl_global_json_parser_enum, 0 };
                        buf = flatcc_json_parser_bool(ctx, (mark = buf), end, &val);
                        if (mark == buf) {
                            buf = flatcc_json_parser_symbolic_bool(ctx, (mark = buf), end, symbolic_parsers, &val);
                            if (buf == mark || buf == end) goto failed;
                        }
                        if (val != 0 || (ctx->flags & flatcc_json_parser_f_force_add)) {
                            if (!(pval = flatcc_builder_table_add(ctx->ctx, 0, 1, 1))) goto failed;
                            flatbuffers_bool_write_to_pe(pval, val);
                        }
                    } else {
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    }
                } else { /* "d" */
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                } /* "d" */
            } else { /* prefix "is_signe" */
                buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
            } /* prefix "is_signe" */
        } /* branch "is_signe" */
        buf = flatcc_json_parser_object_end(ctx, buf, end, &more);
    }
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_struct_field_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end)
{
    int more;
    void *pval;
    flatcc_builder_ref_t ref, *pref;
    const char *mark;
    uint64_t w;
    flatcc_json_parser_escape_buffer_t code;

    if (flatcc_builder_start_table(ctx->ctx, 3)) goto failed;
    buf = flatcc_json_parser_object_start(ctx, buf, end, &more);
    while (more) {
        buf = flatcc_json_parser_symbol_start(ctx, buf, end);
        w = flatcc_json_parser_symbol_part(buf, end);
        if (w < 0x6f66667365740000) { /* branch "offset" */
            if ((w & 0xffffffff00000000) == 0x6e616d6500000000) { /* "name" */
                buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 4);
                if (mark != buf) {
                    buf = flatcc_json_parser_string_start(ctx, buf, end);
                    buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                    if (buf != end && *buf == '\"') {
                        ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                    } else {
                        if (flatcc_builder_start_string(ctx->ctx) ||
                                0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                        while (buf != end && *buf != '\"') {
                            buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                            if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                            if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                                if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                            }
                        }
                        ref = flatcc_builder_end_string(ctx->ctx);
                    }
                    buf = flatcc_json_parser_string_end(ctx, buf, end);
                    if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 0))) goto failed;
                    *pref = ref;
                } else {
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                }
            } else { /* "name" */
                buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
            } /* "name" */
        } else { /* branch "offset" */
            if ((w & 0xffffffff00000000) == 0x7479706500000000) { /* "type" */
                buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 4);
                if (mark != buf) {
                    buf = flatcc_json_parser_string_start(ctx, buf, end);
                    buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                    if (buf != end && *buf == '\"') {
                        ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                    } else {
                        if (flatcc_builder_start_string(ctx->ctx) ||
                                0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                        while (buf != end && *buf != '\"') {
                            buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                            if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                            if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                                if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                            }
                        }
                        ref = flatcc_builder_end_string(ctx->ctx);
                    }
                    buf = flatcc_json_parser_string_end(ctx, buf, end);
                    if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 1))) goto failed;
                    *pref = ref;
                } else {
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                }
            } else { /* "type" */
                if ((w & 0xffffffffffff0000) == 0x6f66667365740000) { /* "offset" */
                    buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 6);
                    if (mark != buf) {
                        uint32_t val = 0;
                        static flatcc_json_parser_integral_symbol_f *symbolic_parsers[] = {
                                ddl_local_dsim_ddl_json_parser_enum,
                                ddl_global_json_parser_enum, 0 };
                        buf = flatcc_json_parser_uint32(ctx, (mark = buf), end, &val);
                        if (mark == buf) {
                            buf = flatcc_json_parser_symbolic_uint32(ctx, (mark = buf), end, symbolic_parsers, &val);
                            if (buf == mark || buf == end) goto failed;
                        }
                        if (val != 0 || (ctx->flags & flatcc_json_parser_f_force_add)) {
                            if (!(pval = flatcc_builder_table_add(ctx->ctx, 2, 4, 4))) goto failed;
                            flatbuffers_uint32_write_to_pe(pval, val);
                        }
                    } else {
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    }
                } else { /* "offset" */
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                } /* "offset" */
            } /* "type" */
        } /* branch "offset" */
        buf = flatcc_json_parser_object_end(ctx, buf, end, &more);
    }
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_struct_type_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end)
{
    int more;
    void *pval;
    flatcc_builder_ref_t ref, *pref;
    const char *mark;
    uint64_t w;
    flatcc_json_parser_escape_buffer_t code;

    if (flatcc_builder_start_table(ctx->ctx, 1)) goto failed;
    buf = flatcc_json_parser_object_start(ctx, buf, end, &more);
    while (more) {
        buf = flatcc_json_parser_symbol_start(ctx, buf, end);
        w = flatcc_json_parser_symbol_part(buf, end);
        if ((w & 0xffffffffffff0000) == 0x6669656c64730000) { /* "fields" */
            buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 6);
            if (mark != buf) {
                if (flatcc_builder_start_offset_vector(ctx->ctx)) goto failed;
                buf = flatcc_json_parser_array_start(ctx, buf, end, &more);
                while (more) {
                    buf = dsim_ddl_struct_field_parse_json_table(ctx, buf, end);
                    if (buf == end) goto failed;
                    ref = flatcc_builder_end_table(ctx->ctx);
                    if (!(pref = flatcc_builder_extend_offset_vector(ctx->ctx, 1))) goto failed;
                    *pref = ref;
                    buf = flatcc_json_parser_array_end(ctx, buf, end, &more);
                }
                ref = flatcc_builder_end_offset_vector(ctx->ctx);
                if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 0))) goto failed;
                *pref = ref;
            } else {
                buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
            }
        } else { /* "fields" */
            buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
        } /* "fields" */
        buf = flatcc_json_parser_object_end(ctx, buf, end, &more);
    }
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_enum_type_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end)
{
    int more;
    void *pval;
    flatcc_builder_ref_t ref, *pref;
    const char *mark;
    uint64_t w;
    flatcc_json_parser_escape_buffer_t code;

    if (flatcc_builder_start_table(ctx->ctx, 1)) goto failed;
    buf = flatcc_json_parser_object_start(ctx, buf, end, &more);
    while (more) {
        buf = flatcc_json_parser_symbol_start(ctx, buf, end);
        w = flatcc_json_parser_symbol_part(buf, end);
        if ((w & 0xffffffffffff0000) == 0x76616c7565730000) { /* "values" */
            buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 6);
            if (mark != buf) {
                if (flatcc_builder_start_offset_vector(ctx->ctx)) goto failed;
                buf = flatcc_json_parser_array_start(ctx, buf, end, &more);
                while (more) {
                    buf = flatcc_json_parser_string_start(ctx, buf, end);
                    buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                    if (buf != end && *buf == '\"') {
                        ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                    } else {
                        if (flatcc_builder_start_string(ctx->ctx) ||
                                0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                        while (buf != end && *buf != '\"') {
                            buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                            if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                            if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                                if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                            }
                        }
                        ref = flatcc_builder_end_string(ctx->ctx);
                    }
                    buf = flatcc_json_parser_string_end(ctx, buf, end);
                    if (!(pref = flatcc_builder_extend_offset_vector(ctx->ctx, 1))) goto failed;
                    *pref = ref;
                    buf = flatcc_json_parser_array_end(ctx, buf, end, &more);
                }
                ref = flatcc_builder_end_offset_vector(ctx->ctx);
                if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 0))) goto failed;
                *pref = ref;
            } else {
                buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
            }
        } else { /* "values" */
            buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
        } /* "values" */
        buf = flatcc_json_parser_object_end(ctx, buf, end, &more);
    }
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_reference_type_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end)
{
    int more;
    void *pval;
    flatcc_builder_ref_t ref, *pref;
    const char *mark;
    uint64_t w;
    flatcc_json_parser_escape_buffer_t code;

    if (flatcc_builder_start_table(ctx->ctx, 1)) goto failed;
    buf = flatcc_json_parser_object_start(ctx, buf, end, &more);
    while (more) {
        buf = flatcc_json_parser_symbol_start(ctx, buf, end);
        w = flatcc_json_parser_symbol_part(buf, end);
        if (w == 0x73746f7261676573) { /* "storages" */
            buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 8);
            if (mark != buf) {
                if (flatcc_builder_start_offset_vector(ctx->ctx)) goto failed;
                buf = flatcc_json_parser_array_start(ctx, buf, end, &more);
                while (more) {
                    buf = flatcc_json_parser_string_start(ctx, buf, end);
                    buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                    if (buf != end && *buf == '\"') {
                        ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                    } else {
                        if (flatcc_builder_start_string(ctx->ctx) ||
                                0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                        while (buf != end && *buf != '\"') {
                            buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                            if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                            if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                                if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                            }
                        }
                        ref = flatcc_builder_end_string(ctx->ctx);
                    }
                    buf = flatcc_json_parser_string_end(ctx, buf, end);
                    if (!(pref = flatcc_builder_extend_offset_vector(ctx->ctx, 1))) goto failed;
                    *pref = ref;
                    buf = flatcc_json_parser_array_end(ctx, buf, end, &more);
                }
                ref = flatcc_builder_end_offset_vector(ctx->ctx);
                if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 0))) goto failed;
                *pref = ref;
            } else {
                buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
            }
        } else { /* "storages" */
            buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
        } /* "storages" */
        buf = flatcc_json_parser_object_end(ctx, buf, end, &more);
    }
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_any_type_parse_json_union(flatcc_json_parser_t *ctx, const char *buf, const char *end, uint8_t type, flatbuffers_voffset_t id)
{
    flatcc_builder_ref_t ref, *pref;
    uint8_t *ptype;

    switch (type) {
    case 0:
        return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_union_none);
    case 1:
        buf = dsim_ddl_numeric_type_parse_json_table(ctx, buf, end);
        break;
    case 2:
        buf = dsim_ddl_struct_type_parse_json_table(ctx, buf, end);
        break;
    case 3:
        buf = dsim_ddl_enum_type_parse_json_table(ctx, buf, end);
        break;
    case 4:
        buf = dsim_ddl_reference_type_parse_json_table(ctx, buf, end);
        break;
    default:
        if (!(ctx->flags & flatcc_json_parser_f_skip_unknown)) {
            return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_unknown_union);
        } else {
            return flatcc_json_parser_generic_json(ctx, buf, end);
        }
    }
    if (buf != end) {
        if(!(ref = flatcc_builder_end_table(ctx->ctx))) goto failed;
        if (!(pref = flatcc_builder_table_add_offset(ctx->ctx, id))) goto failed;
        *pref = ref;
        if (!(ptype = flatcc_builder_table_add(ctx->ctx, id - 1, 1, 1))) goto failed;
        *ptype = type;
    }
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_any_type_parse_json_enum(flatcc_json_parser_t *ctx, const char *buf, const char *end,
        int *value_sign, uint64_t *value, int *aggregate)
{
    const char *unmatched = buf;
    const char *mark;
    uint64_t w;

    w = flatcc_json_parser_symbol_part(buf, end);
    if (w < 0x6e756d657269635f) { /* branch "numeric_" */
        if (w < 0x656e756d5f747970) { /* branch "enum_typ" */
            if ((w & 0xffffffff00000000) == 0x4e4f4e4500000000) { /* "NONE" */
                buf = flatcc_json_parser_match_constant(ctx, (mark = buf), end, 4, aggregate);
                if (buf != mark) {
                    *value = 0, *value_sign = 0;
                } else {
                    return unmatched;
                }
            } else { /* "NONE" */
                return unmatched;
            } /* "NONE" */
        } else { /* branch "enum_typ" */
            if (w == 0x656e756d5f747970) { /* prefix "enum_typ" */
                buf += 8;
                w = flatcc_json_parser_symbol_part(buf, end);
                if ((w & 0xff00000000000000) == 0x6500000000000000) { /* "e" */
                    buf = flatcc_json_parser_match_constant(ctx, (mark = buf), end, 1, aggregate);
                    if (buf != mark) {
                        *value = 3, *value_sign = 0;
                    } else {
                        return unmatched;
                    }
                } else { /* "e" */
                    return unmatched;
                } /* "e" */
            } else { /* prefix "enum_typ" */
                return unmatched;
            } /* prefix "enum_typ" */
        } /* branch "enum_typ" */
    } else { /* branch "numeric_" */
        if (w < 0x7265666572656e63) { /* branch "referenc" */
            if (w == 0x6e756d657269635f) { /* prefix "numeric_" */
                buf += 8;
                w = flatcc_json_parser_symbol_part(buf, end);
                if ((w & 0xffffffff00000000) == 0x7479706500000000) { /* "type" */
                    buf = flatcc_json_parser_match_constant(ctx, (mark = buf), end, 4, aggregate);
                    if (buf != mark) {
                        *value = 1, *value_sign = 0;
                    } else {
                        return unmatched;
                    }
                } else { /* "type" */
                    return unmatched;
                } /* "type" */
            } else { /* prefix "numeric_" */
                return unmatched;
            } /* prefix "numeric_" */
        } else { /* branch "referenc" */
            if (w < 0x7374727563745f74) { /* branch "struct_t" */
                if (w == 0x7265666572656e63) { /* prefix "referenc" */
                    buf += 8;
                    w = flatcc_json_parser_symbol_part(buf, end);
                    if ((w & 0xffffffffffff0000) == 0x655f747970650000) { /* "e_type" */
                        buf = flatcc_json_parser_match_constant(ctx, (mark = buf), end, 6, aggregate);
                        if (buf != mark) {
                            *value = 4, *value_sign = 0;
                        } else {
                            return unmatched;
                        }
                    } else { /* "e_type" */
                        return unmatched;
                    } /* "e_type" */
                } else { /* prefix "referenc" */
                    return unmatched;
                } /* prefix "referenc" */
            } else { /* branch "struct_t" */
                if (w == 0x7374727563745f74) { /* prefix "struct_t" */
                    buf += 8;
                    w = flatcc_json_parser_symbol_part(buf, end);
                    if ((w & 0xffffff0000000000) == 0x7970650000000000) { /* "ype" */
                        buf = flatcc_json_parser_match_constant(ctx, (mark = buf), end, 3, aggregate);
                        if (buf != mark) {
                            *value = 2, *value_sign = 0;
                        } else {
                            return unmatched;
                        }
                    } else { /* "ype" */
                        return unmatched;
                    } /* "ype" */
                } else { /* prefix "struct_t" */
                    return unmatched;
                } /* prefix "struct_t" */
            } /* branch "struct_t" */
        } /* branch "referenc" */
    } /* branch "numeric_" */
    return buf;
}

static const char *dsim_ddl_type_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end)
{
    int more;
    void *pval;
    flatcc_builder_ref_t ref, *pref;
    const char *mark;
    uint64_t w;
    flatcc_json_parser_escape_buffer_t code;

    if (flatcc_builder_start_table(ctx->ctx, 6)) goto failed;
    if (end == flatcc_json_parser_prepare_unions(ctx, buf, end, 2)) goto failed;
    buf = flatcc_json_parser_object_start(ctx, buf, end, &more);
    while (more) {
        buf = flatcc_json_parser_symbol_start(ctx, buf, end);
        w = flatcc_json_parser_symbol_part(buf, end);
        if (w < 0x6461746100000000) { /* branch "data" */
            if ((w & 0xffffffffff000000) == 0x6374797065000000) { /* "ctype" */
                buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 5);
                if (mark != buf) {
                    buf = flatcc_json_parser_string_start(ctx, buf, end);
                    buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                    if (buf != end && *buf == '\"') {
                        ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                    } else {
                        if (flatcc_builder_start_string(ctx->ctx) ||
                                0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                        while (buf != end && *buf != '\"') {
                            buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                            if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                            if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                                if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                            }
                        }
                        ref = flatcc_builder_end_string(ctx->ctx);
                    }
                    buf = flatcc_json_parser_string_end(ctx, buf, end);
                    if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 1))) goto failed;
                    *pref = ref;
                } else {
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                }
            } else { /* "ctype" */
                if ((w & 0xffffffffff000000) == 0x616c69676e000000) { /* "align" */
                    buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 5);
                    if (mark != buf) {
                        uint8_t val = 0;
                        static flatcc_json_parser_integral_symbol_f *symbolic_parsers[] = {
                                ddl_local_dsim_ddl_json_parser_enum,
                                ddl_global_json_parser_enum, 0 };
                        buf = flatcc_json_parser_uint8(ctx, (mark = buf), end, &val);
                        if (mark == buf) {
                            buf = flatcc_json_parser_symbolic_uint8(ctx, (mark = buf), end, symbolic_parsers, &val);
                            if (buf == mark || buf == end) goto failed;
                        }
                        if (val != 0 || (ctx->flags & flatcc_json_parser_f_force_add)) {
                            if (!(pval = flatcc_builder_table_add(ctx->ctx, 3, 1, 1))) goto failed;
                            flatbuffers_uint8_write_to_pe(pval, val);
                        }
                    } else {
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    }
                } else { /* "align" */
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                } /* "align" */
            } /* "ctype" */
        } else { /* branch "data" */
            if (w < 0x6e616d6500000000) { /* branch "name" */
                if (w == 0x646174615f747970) { /* prefix "data_typ" */
                    buf += 8;
                    w = flatcc_json_parser_symbol_part(buf, end);
                    if ((w & 0xff00000000000000) == 0x6500000000000000) { /* "e" */
                        buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 1);
                        if (mark != buf) {
                            static flatcc_json_parser_integral_symbol_f *symbolic_parsers[] = {
                                    dsim_ddl_any_type_parse_json_enum,
                                    ddl_local_dsim_ddl_json_parser_enum,
                                    ddl_global_json_parser_enum, 0 };
                            buf = flatcc_json_parser_union_type(ctx, buf, end, 1, 5, symbolic_parsers, dsim_ddl_any_type_parse_json_union);
                        } else {
                            buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                        }
                    } else { /* "e" */
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    } /* "e" */
                } else { /* prefix "data_typ" */
                    if ((w & 0xffffffff00000000) == 0x6461746100000000) { /* "data" */
                        buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 4);
                        if (mark != buf) {
                            buf = flatcc_json_parser_union(ctx, buf, end, 1, 5, dsim_ddl_any_type_parse_json_union);
                        } else {
                            buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                        }
                    } else { /* "data" */
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    } /* "data" */
                } /* prefix "data_typ" */
            } else { /* branch "name" */
                if ((w & 0xffffffff00000000) == 0x73697a6500000000) { /* "size" */
                    buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 4);
                    if (mark != buf) {
                        uint8_t val = 0;
                        static flatcc_json_parser_integral_symbol_f *symbolic_parsers[] = {
                                ddl_local_dsim_ddl_json_parser_enum,
                                ddl_global_json_parser_enum, 0 };
                        buf = flatcc_json_parser_uint8(ctx, (mark = buf), end, &val);
                        if (mark == buf) {
                            buf = flatcc_json_parser_symbolic_uint8(ctx, (mark = buf), end, symbolic_parsers, &val);
                            if (buf == mark || buf == end) goto failed;
                        }
                        if (val != 0 || (ctx->flags & flatcc_json_parser_f_force_add)) {
                            if (!(pval = flatcc_builder_table_add(ctx->ctx, 2, 1, 1))) goto failed;
                            flatbuffers_uint8_write_to_pe(pval, val);
                        }
                    } else {
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    }
                } else { /* "size" */
                    if ((w & 0xffffffff00000000) == 0x6e616d6500000000) { /* "name" */
                        buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 4);
                        if (mark != buf) {
                            buf = flatcc_json_parser_string_start(ctx, buf, end);
                            buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                            if (buf != end && *buf == '\"') {
                                ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                            } else {
                                if (flatcc_builder_start_string(ctx->ctx) ||
                                        0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                                while (buf != end && *buf != '\"') {
                                    buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                                    if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                                    if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                                        if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                                    }
                                }
                                ref = flatcc_builder_end_string(ctx->ctx);
                            }
                            buf = flatcc_json_parser_string_end(ctx, buf, end);
                            if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 0))) goto failed;
                            *pref = ref;
                        } else {
                            buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                        }
                    } else { /* "name" */
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    } /* "name" */
                } /* "size" */
            } /* branch "name" */
        } /* branch "data" */
        buf = flatcc_json_parser_object_end(ctx, buf, end, &more);
    }
    buf = flatcc_json_parser_finalize_unions(ctx, buf, end);
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_array_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end)
{
    int more;
    void *pval;
    flatcc_builder_ref_t ref, *pref;
    const char *mark;
    uint64_t w;
    flatcc_json_parser_escape_buffer_t code;

    if (flatcc_builder_start_table(ctx->ctx, 2)) goto failed;
    buf = flatcc_json_parser_object_start(ctx, buf, end, &more);
    while (more) {
        buf = flatcc_json_parser_symbol_start(ctx, buf, end);
        w = flatcc_json_parser_symbol_part(buf, end);
        if ((w & 0xffffffff00000000) == 0x7479706500000000) { /* "type" */
            buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 4);
            if (mark != buf) {
                buf = flatcc_json_parser_string_start(ctx, buf, end);
                buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                if (buf != end && *buf == '\"') {
                    ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                } else {
                    if (flatcc_builder_start_string(ctx->ctx) ||
                            0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                    while (buf != end && *buf != '\"') {
                        buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                        if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                        if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                            if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                        }
                    }
                    ref = flatcc_builder_end_string(ctx->ctx);
                }
                buf = flatcc_json_parser_string_end(ctx, buf, end);
                if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 1))) goto failed;
                *pref = ref;
            } else {
                buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
            }
        } else { /* "type" */
            if ((w & 0xffffffff00000000) == 0x6e616d6500000000) { /* "name" */
                buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 4);
                if (mark != buf) {
                    buf = flatcc_json_parser_string_start(ctx, buf, end);
                    buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                    if (buf != end && *buf == '\"') {
                        ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                    } else {
                        if (flatcc_builder_start_string(ctx->ctx) ||
                                0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                        while (buf != end && *buf != '\"') {
                            buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                            if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                            if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                                if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                            }
                        }
                        ref = flatcc_builder_end_string(ctx->ctx);
                    }
                    buf = flatcc_json_parser_string_end(ctx, buf, end);
                    if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 0))) goto failed;
                    *pref = ref;
                } else {
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                }
            } else { /* "name" */
                buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
            } /* "name" */
        } /* "type" */
        buf = flatcc_json_parser_object_end(ctx, buf, end, &more);
    }
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_layout_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end)
{
    int more;
    void *pval;
    flatcc_builder_ref_t ref, *pref;
    const char *mark;
    uint64_t w;
    flatcc_json_parser_escape_buffer_t code;

    if (flatcc_builder_start_table(ctx->ctx, 2)) goto failed;
    buf = flatcc_json_parser_object_start(ctx, buf, end, &more);
    while (more) {
        buf = flatcc_json_parser_symbol_start(ctx, buf, end);
        w = flatcc_json_parser_symbol_part(buf, end);
        if ((w & 0xffffffff00000000) == 0x6e616d6500000000) { /* "name" */
            buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 4);
            if (mark != buf) {
                buf = flatcc_json_parser_string_start(ctx, buf, end);
                buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                if (buf != end && *buf == '\"') {
                    ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                } else {
                    if (flatcc_builder_start_string(ctx->ctx) ||
                            0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                    while (buf != end && *buf != '\"') {
                        buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                        if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                        if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                            if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                        }
                    }
                    ref = flatcc_builder_end_string(ctx->ctx);
                }
                buf = flatcc_json_parser_string_end(ctx, buf, end);
                if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 0))) goto failed;
                *pref = ref;
            } else {
                buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
            }
        } else { /* "name" */
            if ((w & 0xffffffffffff0000) == 0x6172726179730000) { /* "arrays" */
                buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 6);
                if (mark != buf) {
                    if (flatcc_builder_start_offset_vector(ctx->ctx)) goto failed;
                    buf = flatcc_json_parser_array_start(ctx, buf, end, &more);
                    while (more) {
                        buf = dsim_ddl_array_parse_json_table(ctx, buf, end);
                        if (buf == end) goto failed;
                        ref = flatcc_builder_end_table(ctx->ctx);
                        if (!(pref = flatcc_builder_extend_offset_vector(ctx->ctx, 1))) goto failed;
                        *pref = ref;
                        buf = flatcc_json_parser_array_end(ctx, buf, end, &more);
                    }
                    ref = flatcc_builder_end_offset_vector(ctx->ctx);
                    if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 1))) goto failed;
                    *pref = ref;
                } else {
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                }
            } else { /* "arrays" */
                buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
            } /* "arrays" */
        } /* "name" */
        buf = flatcc_json_parser_object_end(ctx, buf, end, &more);
    }
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_storage_engine_parse_json_union(flatcc_json_parser_t *ctx, const char *buf, const char *end, uint8_t type, flatbuffers_voffset_t id)
{
    flatcc_builder_ref_t ref, *pref;
    uint8_t *ptype;

    switch (type) {
    case 0:
        return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_union_none);
    case 1:
        buf = dsim_ddl_hash_storage_parse_json_table(ctx, buf, end);
        break;
    default:
        if (!(ctx->flags & flatcc_json_parser_f_skip_unknown)) {
            return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_unknown_union);
        } else {
            return flatcc_json_parser_generic_json(ctx, buf, end);
        }
    }
    if (buf != end) {
        if(!(ref = flatcc_builder_end_table(ctx->ctx))) goto failed;
        if (!(pref = flatcc_builder_table_add_offset(ctx->ctx, id))) goto failed;
        *pref = ref;
        if (!(ptype = flatcc_builder_table_add(ctx->ctx, id - 1, 1, 1))) goto failed;
        *ptype = type;
    }
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_storage_engine_parse_json_enum(flatcc_json_parser_t *ctx, const char *buf, const char *end,
        int *value_sign, uint64_t *value, int *aggregate)
{
    const char *unmatched = buf;
    const char *mark;
    uint64_t w;

    w = flatcc_json_parser_symbol_part(buf, end);
    if (w < 0x686173685f73746f) { /* branch "hash_sto" */
        if ((w & 0xffffffff00000000) == 0x4e4f4e4500000000) { /* "NONE" */
            buf = flatcc_json_parser_match_constant(ctx, (mark = buf), end, 4, aggregate);
            if (buf != mark) {
                *value = 0, *value_sign = 0;
            } else {
                return unmatched;
            }
        } else { /* "NONE" */
            return unmatched;
        } /* "NONE" */
    } else { /* branch "hash_sto" */
        if (w == 0x686173685f73746f) { /* prefix "hash_sto" */
            buf += 8;
            w = flatcc_json_parser_symbol_part(buf, end);
            if ((w & 0xffffffff00000000) == 0x7261676500000000) { /* "rage" */
                buf = flatcc_json_parser_match_constant(ctx, (mark = buf), end, 4, aggregate);
                if (buf != mark) {
                    *value = 1, *value_sign = 0;
                } else {
                    return unmatched;
                }
            } else { /* "rage" */
                return unmatched;
            } /* "rage" */
        } else { /* prefix "hash_sto" */
            return unmatched;
        } /* prefix "hash_sto" */
    } /* branch "hash_sto" */
    return buf;
}

static const char *dsim_ddl_hash_storage_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end)
{
    int more;

    if (flatcc_builder_start_table(ctx->ctx, 0)) goto failed;
    buf = flatcc_json_parser_object_start(ctx, buf, end, &more);
    while (more) {
        buf = flatcc_json_parser_symbol_start(ctx, buf, end);
        /* Table has no fields. */
        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
        buf = flatcc_json_parser_object_end(ctx, buf, end, &more);
    }
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_storage_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end)
{
    int more;
    void *pval;
    flatcc_builder_ref_t ref, *pref;
    const char *mark;
    uint64_t w;
    flatcc_json_parser_escape_buffer_t code;

    if (flatcc_builder_start_table(ctx->ctx, 5)) goto failed;
    if (end == flatcc_json_parser_prepare_unions(ctx, buf, end, 2)) goto failed;
    buf = flatcc_json_parser_object_start(ctx, buf, end, &more);
    while (more) {
        buf = flatcc_json_parser_symbol_start(ctx, buf, end);
        w = flatcc_json_parser_symbol_part(buf, end);
        if (w < 0x6c61796f75740000) { /* branch "layout" */
            if (w == 0x656e67696e655f74) { /* prefix "engine_t" */
                buf += 8;
                w = flatcc_json_parser_symbol_part(buf, end);
                if ((w & 0xffffff0000000000) == 0x7970650000000000) { /* "ype" */
                    buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 3);
                    if (mark != buf) {
                        static flatcc_json_parser_integral_symbol_f *symbolic_parsers[] = {
                                dsim_ddl_storage_engine_parse_json_enum,
                                ddl_local_dsim_ddl_json_parser_enum,
                                ddl_global_json_parser_enum, 0 };
                        buf = flatcc_json_parser_union_type(ctx, buf, end, 1, 4, symbolic_parsers, dsim_ddl_storage_engine_parse_json_union);
                    } else {
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    }
                } else { /* "ype" */
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                } /* "ype" */
            } else { /* prefix "engine_t" */
                if ((w & 0xffffffffffff0000) == 0x656e67696e650000) { /* "engine" */
                    buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 6);
                    if (mark != buf) {
                        buf = flatcc_json_parser_union(ctx, buf, end, 1, 4, dsim_ddl_storage_engine_parse_json_union);
                    } else {
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    }
                } else { /* "engine" */
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                } /* "engine" */
            } /* prefix "engine_t" */
        } else { /* branch "layout" */
            if (w < 0x6e616d6500000000) { /* branch "name" */
                if ((w & 0xffffffffffff0000) == 0x6c61796f75740000) { /* "layout" */
                    buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 6);
                    if (mark != buf) {
                        buf = flatcc_json_parser_string_start(ctx, buf, end);
                        buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                        if (buf != end && *buf == '\"') {
                            ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                        } else {
                            if (flatcc_builder_start_string(ctx->ctx) ||
                                    0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                            while (buf != end && *buf != '\"') {
                                buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                                if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                                if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                                    if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                                }
                            }
                            ref = flatcc_builder_end_string(ctx->ctx);
                        }
                        buf = flatcc_json_parser_string_end(ctx, buf, end);
                        if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 1))) goto failed;
                        *pref = ref;
                    } else {
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    }
                } else { /* "layout" */
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                } /* "layout" */
            } else { /* branch "name" */
                if (w == 0x7265665f74797065) { /* "ref_type" */
                    buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 8);
                    if (mark != buf) {
                        buf = flatcc_json_parser_string_start(ctx, buf, end);
                        buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                        if (buf != end && *buf == '\"') {
                            ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                        } else {
                            if (flatcc_builder_start_string(ctx->ctx) ||
                                    0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                            while (buf != end && *buf != '\"') {
                                buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                                if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                                if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                                    if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                                }
                            }
                            ref = flatcc_builder_end_string(ctx->ctx);
                        }
                        buf = flatcc_json_parser_string_end(ctx, buf, end);
                        if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 2))) goto failed;
                        *pref = ref;
                    } else {
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    }
                } else { /* "ref_type" */
                    if ((w & 0xffffffff00000000) == 0x6e616d6500000000) { /* "name" */
                        buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 4);
                        if (mark != buf) {
                            buf = flatcc_json_parser_string_start(ctx, buf, end);
                            buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                            if (buf != end && *buf == '\"') {
                                ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                            } else {
                                if (flatcc_builder_start_string(ctx->ctx) ||
                                        0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                                while (buf != end && *buf != '\"') {
                                    buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                                    if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                                    if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                                        if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                                    }
                                }
                                ref = flatcc_builder_end_string(ctx->ctx);
                            }
                            buf = flatcc_json_parser_string_end(ctx, buf, end);
                            if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 0))) goto failed;
                            *pref = ref;
                        } else {
                            buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                        }
                    } else { /* "name" */
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    } /* "name" */
                } /* "ref_type" */
            } /* branch "name" */
        } /* branch "layout" */
        buf = flatcc_json_parser_object_end(ctx, buf, end, &more);
    }
    buf = flatcc_json_parser_finalize_unions(ctx, buf, end);
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *dsim_ddl_root_parse_json_table(flatcc_json_parser_t *ctx, const char *buf, const char *end)
{
    int more;
    void *pval;
    flatcc_builder_ref_t ref, *pref;
    const char *mark;
    uint64_t w;
    flatcc_json_parser_escape_buffer_t code;

    if (flatcc_builder_start_table(ctx->ctx, 4)) goto failed;
    buf = flatcc_json_parser_object_start(ctx, buf, end, &more);
    while (more) {
        buf = flatcc_json_parser_symbol_start(ctx, buf, end);
        w = flatcc_json_parser_symbol_part(buf, end);
        if (w < 0x6e616d6500000000) { /* branch "name" */
            if ((w & 0xffffffffffffff00) == 0x6c61796f75747300) { /* "layouts" */
                buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 7);
                if (mark != buf) {
                    if (flatcc_builder_start_offset_vector(ctx->ctx)) goto failed;
                    buf = flatcc_json_parser_array_start(ctx, buf, end, &more);
                    while (more) {
                        buf = dsim_ddl_layout_parse_json_table(ctx, buf, end);
                        if (buf == end) goto failed;
                        ref = flatcc_builder_end_table(ctx->ctx);
                        if (!(pref = flatcc_builder_extend_offset_vector(ctx->ctx, 1))) goto failed;
                        *pref = ref;
                        buf = flatcc_json_parser_array_end(ctx, buf, end, &more);
                    }
                    ref = flatcc_builder_end_offset_vector(ctx->ctx);
                    if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 2))) goto failed;
                    *pref = ref;
                } else {
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                }
            } else { /* "layouts" */
                buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
            } /* "layouts" */
        } else { /* branch "name" */
            if (w < 0x73746f7261676573) { /* branch "storages" */
                if ((w & 0xffffffff00000000) == 0x6e616d6500000000) { /* "name" */
                    buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 4);
                    if (mark != buf) {
                        buf = flatcc_json_parser_string_start(ctx, buf, end);
                        buf = flatcc_json_parser_string_part(ctx, (mark = buf), end);
                        if (buf != end && *buf == '\"') {
                            ref = flatcc_builder_create_string(ctx->ctx, mark, buf - mark);
                        } else {
                            if (flatcc_builder_start_string(ctx->ctx) ||
                                    0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                            while (buf != end && *buf != '\"') {
                                buf = flatcc_json_parser_string_escape(ctx, buf, end, code);
                                if (0 == flatcc_builder_append_string(ctx->ctx, code + 1, code[0])) goto failed;
                                if (end != (buf = flatcc_json_parser_string_part(ctx, (mark = buf), end))) {
                                    if (0 == flatcc_builder_append_string(ctx->ctx, mark, buf - mark)) goto failed;
                                }
                            }
                            ref = flatcc_builder_end_string(ctx->ctx);
                        }
                        buf = flatcc_json_parser_string_end(ctx, buf, end);
                        if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 0))) goto failed;
                        *pref = ref;
                    } else {
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    }
                } else { /* "name" */
                    buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                } /* "name" */
            } else { /* branch "storages" */
                if ((w & 0xffffffffff000000) == 0x7479706573000000) { /* "types" */
                    buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 5);
                    if (mark != buf) {
                        if (flatcc_builder_start_offset_vector(ctx->ctx)) goto failed;
                        buf = flatcc_json_parser_array_start(ctx, buf, end, &more);
                        while (more) {
                            buf = dsim_ddl_type_parse_json_table(ctx, buf, end);
                            if (buf == end) goto failed;
                            ref = flatcc_builder_end_table(ctx->ctx);
                            if (!(pref = flatcc_builder_extend_offset_vector(ctx->ctx, 1))) goto failed;
                            *pref = ref;
                            buf = flatcc_json_parser_array_end(ctx, buf, end, &more);
                        }
                        ref = flatcc_builder_end_offset_vector(ctx->ctx);
                        if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 1))) goto failed;
                        *pref = ref;
                    } else {
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    }
                } else { /* "types" */
                    if (w == 0x73746f7261676573) { /* "storages" */
                        buf = flatcc_json_parser_match_symbol(ctx, (mark = buf), end, 8);
                        if (mark != buf) {
                            if (flatcc_builder_start_offset_vector(ctx->ctx)) goto failed;
                            buf = flatcc_json_parser_array_start(ctx, buf, end, &more);
                            while (more) {
                                buf = dsim_ddl_storage_parse_json_table(ctx, buf, end);
                                if (buf == end) goto failed;
                                ref = flatcc_builder_end_table(ctx->ctx);
                                if (!(pref = flatcc_builder_extend_offset_vector(ctx->ctx, 1))) goto failed;
                                *pref = ref;
                                buf = flatcc_json_parser_array_end(ctx, buf, end, &more);
                            }
                            ref = flatcc_builder_end_offset_vector(ctx->ctx);
                            if (!ref || !(pref = flatcc_builder_table_add_offset(ctx->ctx, 3))) goto failed;
                            *pref = ref;
                        } else {
                            buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                        }
                    } else { /* "storages" */
                        buf = flatcc_json_parser_unmatched_symbol(ctx, buf, end);
                    } /* "storages" */
                } /* "types" */
            } /* branch "storages" */
        } /* branch "name" */
        buf = flatcc_json_parser_object_end(ctx, buf, end, &more);
    }
    return buf;
failed:
    return flatcc_json_parser_set_error(ctx, buf, end, flatcc_json_parser_error_runtime);
}

static const char *ddl_local_json_parser_enum(flatcc_json_parser_t *ctx, const char *buf, const char *end,
        int *value_type, uint64_t *value, int *aggregate)
{
    /* Scope has no enum / union types to look up. */
    return buf; /* unmatched; */
}

static const char *ddl_local_dsim_ddl_json_parser_enum(flatcc_json_parser_t *ctx, const char *buf, const char *end,
        int *value_type, uint64_t *value, int *aggregate)
{
    /* Scope has no enum / union types to look up. */
    return buf; /* unmatched; */
}

static const char *ddl_global_json_parser_enum(flatcc_json_parser_t *ctx, const char *buf, const char *end,
        int *value_type, uint64_t *value, int *aggregate)
{
    const char *unmatched = buf;
    const char *mark;
    uint64_t w;

    w = flatcc_json_parser_symbol_part(buf, end);
    if (w == 0x6473696d2e64646c) { /* prefix "dsim.ddl" */
        buf += 8;
        w = flatcc_json_parser_symbol_part(buf, end);
        if (w < 0x2e73746f72616765) { /* branch ".storage" */
            if (w == 0x2e616e795f747970) { /* prefix ".any_typ" */
                buf += 8;
                w = flatcc_json_parser_symbol_part(buf, end);
                if ((w & 0xff00000000000000) == 0x6500000000000000) { /* "e" */
                    buf = flatcc_json_parser_match_scope(ctx, (mark = buf), end, 1);
                    if (buf != mark) {
                        buf = dsim_ddl_any_type_parse_json_enum(ctx, buf, end, value_type, value, aggregate);
                    } else {
                        return unmatched;
                    }
                } else { /* "e" */
                    return unmatched;
                } /* "e" */
            } else { /* prefix ".any_typ" */
                return unmatched;
            } /* prefix ".any_typ" */
        } else { /* branch ".storage" */
            if (w == 0x2e73746f72616765) { /* prefix ".storage" */
                buf += 8;
                w = flatcc_json_parser_symbol_part(buf, end);
                if ((w & 0xffffffffffffff00) == 0x5f656e67696e6500) { /* "_engine" */
                    buf = flatcc_json_parser_match_scope(ctx, (mark = buf), end, 7);
                    if (buf != mark) {
                        buf = dsim_ddl_storage_engine_parse_json_enum(ctx, buf, end, value_type, value, aggregate);
                    } else {
                        return unmatched;
                    }
                } else { /* "_engine" */
                    return unmatched;
                } /* "_engine" */
            } else { /* prefix ".storage" */
                return unmatched;
            } /* prefix ".storage" */
        } /* branch ".storage" */
    } else { /* prefix "dsim.ddl" */
        return unmatched;
    } /* prefix "dsim.ddl" */
    return buf;
}

static int ddl_parse_json(flatcc_builder_t *B, flatcc_json_parser_t *ctx,
        const char *buf, size_t bufsiz, int flags)
{
    flatcc_json_parser_t parser;
    flatcc_builder_ref_t root;

    ctx = ctx ? ctx : &parser;
    flatcc_json_parser_init(ctx, B, buf, buf + bufsiz, flags);
    if (flatcc_builder_start_buffer(B, 0, 0, 0)) return -1;
    dsim_ddl_root_parse_json_table(ctx, buf, buf + bufsiz);
    if (ctx->error) {
        return ctx->error;
    }
    root = flatcc_builder_end_table(B);
    if (!flatcc_builder_end_buffer(B, root)) return -1;
    ctx->end_loc = buf;
    return 0;
}

#include "flatcc/portable/pdiagnostic_pop.h"
#endif /* DDL_JSON_PARSER_H */
